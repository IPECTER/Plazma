From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: IPECTER <ipectert@gmail.com>
Date: Tue, 2 May 2023 14:51:20 +0900
Subject: [PATCH] Petal MultiThreadedTracker

Original: Bloom-host/Petal
Copyright (C) 2023 peaches94

diff --git a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
index 0fd814f1d65c111266a2b20f86561839a4cef755..fd3d4a5c4dd90f8629e8e613867a3580a4285322 100644
--- a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
+++ b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
@@ -15,7 +15,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
 
     /* list impl */
     protected E[] listElements;
-    protected int listSize;
+    protected int listSize; public int getListSize() { return listSize; } // Plazma - MultiThreadedTracker: get listSize
 
     protected final double maxFragFactor;
 
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index f597d65d56964297eeeed6c7e77703764178fee0..1130cd688e179c62aa4d38a1d856164fa1d4c950 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -132,7 +132,7 @@ public final class ChunkEntitySlices {
         return this.entities.size() != 0;
     }
 
-    private List<Entity> getAllEntities() {
+    public List<Entity> getAllEntities() { // Plazma - MultiThreadedTracker: private -> public
         final int len = this.entities.size();
         if (len == 0) {
             return new ArrayList<>();
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 57fdef8b16e1ed9a4693356144b4685bbcea285c..257a632e43809cf81f9a12d78bc6dbf9ea0dfd56 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1251,29 +1251,41 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         entity.tracker = null; // Paper - We're no longer tracked
     }
 
+    // Plazma start - MultiThreadedTracker
+    private @Nullable org.plazmamc.plazma.tracker.MultithreadedTracker multithreadedTracker;
+    private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> trackerMainThreadTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    private boolean tracking = false;
+
+    public void runOnTrackerMainThread(final Runnable runnable) {
+        if (this.tracking) {
+            this.trackerMainThreadTasks.add(runnable);
+        } else {
+            runnable.run();
+        }
+    }
+
     // Paper start - optimised tracker
     private final void processTrackQueue() {
-        //this.level.timings.tracker1.startTiming(); // Purpur
-        try {
-            for (TrackedEntity tracker : this.entityMap.values()) {
-                // update tracker entry
-                tracker.updatePlayers(tracker.entity.getPlayersInTrackRange());
+        boolean multiThreadedTrackerEnabled = this.level.plazmaLevelConfiguration().entity.multiThreadedTracker.enabled;
+        if (multiThreadedTrackerEnabled) {
+            if (this.multithreadedTracker == null) this.multithreadedTracker = new org.plazmamc.plazma.tracker.MultithreadedTracker(this.level.chunkSource.entityTickingChunks, this.trackerMainThreadTasks);
+            this.tracking = true;
+            try {
+                this.multithreadedTracker.tick();
+            } finally {
+                this.tracking = false;
             }
-        } finally {
-            //this.level.timings.tracker1.stopTiming(); // Purpur
         }
-
-
-        //this.level.timings.tracker2.startTiming(); // Purpur
-        try {
-            for (TrackedEntity tracker : this.entityMap.values()) {
+        for (TrackedEntity tracker : this.entityMap.values()) {
+            Class<?> superClass = tracker.getClass().getSuperclass();
+            if (!multiThreadedTrackerEnabled || superClass.equals(TrackedEntity.class)) { // check custom tracker
+                tracker.updatePlayers(tracker.entity.getPlayersInTrackRange());
                 tracker.serverEntity.sendChanges();
             }
-        } finally {
-            //this.level.timings.tracker2.stopTiming(); // Purpur
         }
     }
     // Paper end - optimised tracker
+    // Plazma end
 
     protected void tick() {
         // Paper start - optimized tracker
@@ -1510,10 +1522,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public class TrackedEntity {
 
         public final ServerEntity serverEntity;
-        final Entity entity;
+        final Entity entity; public Entity getEntity() { return entity; } // Plazma - MultiThreadedTracker: get entity
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new ReferenceOpenHashSet<>(); // Paper - optimise map impl
+        public final Set<ServerPlayerConnection> seenBy = it.unimi.dsi.fastutil.objects.ReferenceSets.synchronize(new ReferenceOpenHashSet<>()); // Paper - optimise map impl // Plazma - MultiThreadedTracker: sync
 
         public TrackedEntity(Entity entity, int i, int j, boolean flag) {
             this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, j, flag, this::broadcast, this.seenBy); // CraftBukkit
@@ -1525,7 +1537,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper start - use distance map to optimise tracker
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> lastTrackerCandidates;
 
-        final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newTrackerCandidates) {
+        public final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newTrackerCandidates) { // Plazma - MultiThreadedTracker: private -> public
             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> oldTrackerCandidates = this.lastTrackerCandidates;
             this.lastTrackerCandidates = newTrackerCandidates;
 
@@ -1597,7 +1609,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void removePlayer(ServerPlayer player) {
-            org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
+            //org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot // Plazma - MultiThreadedTracker: async
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
             }
@@ -1605,7 +1617,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void updatePlayer(ServerPlayer player) {
-            org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
+            //org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot // Plazma - MultiThreadedTracker: async
             if (player != this.entity) {
                 // Paper start - remove allocation of Vec3D here
                 // Vec3 vec3d = player.position().subtract(this.entity.position());
diff --git a/src/main/java/net/minecraft/server/level/ServerBossEvent.java b/src/main/java/net/minecraft/server/level/ServerBossEvent.java
index ca42c2642a729b90d22b968af7258f3aee72e14b..40261b80d947a6be43465013fae5532197cfe721 100644
--- a/src/main/java/net/minecraft/server/level/ServerBossEvent.java
+++ b/src/main/java/net/minecraft/server/level/ServerBossEvent.java
@@ -13,7 +13,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.BossEvent;
 
 public class ServerBossEvent extends BossEvent {
-    private final Set<ServerPlayer> players = Sets.newHashSet();
+    private final Set<ServerPlayer> players = Sets.newConcurrentHashSet(); // petal - players can be removed in async tracking
     private final Set<ServerPlayer> unmodifiablePlayers = Collections.unmodifiableSet(this.players);
     public boolean visible = true;
 
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index dbb987d5896e199aeae3bcd86c69bf3327af8ada..7c18a99d5230598c796fa93be3248ff0859aa638 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -299,7 +299,7 @@ public class ServerEntity {
 
     public void removePairing(ServerPlayer player) {
         this.entity.stopSeenByPlayer(player);
-        player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
+        ((ServerLevel) this.entity.level).chunkSource.chunkMap.runOnTrackerMainThread(() -> player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}))); // Plazma - MultiThreadedTracker: sync
     }
 
     public void addPairing(ServerPlayer player) {
@@ -307,7 +307,7 @@ public class ServerEntity {
 
         Objects.requireNonNull(list);
         this.sendPairingData(list::add, player); // CraftBukkit - add player
-        player.connection.send(new ClientboundBundlePacket(list));
+        ((ServerLevel) this.entity.level).chunkSource.chunkMap.runOnTrackerMainThread(() -> player.connection.send(new ClientboundBundlePacket(list))); // Plazma - MultiThreadedTracker: sync
         this.entity.startSeenByPlayer(player);
     }
 
@@ -415,21 +415,21 @@ public class ServerEntity {
 
         if (list != null) {
             this.trackedDataValues = datawatcher.getNonDefaultValues();
-            this.broadcastAndSend(new ClientboundSetEntityDataPacket(this.entity.getId(), list));
+            ((ServerLevel) this.entity.level).chunkSource.chunkMap.runOnTrackerMainThread(() -> this.broadcastAndSend(new ClientboundSetEntityDataPacket(this.entity.getId(), list))); // Plazma - MultiThreadedTracker: sync
         }
 
         if (this.entity instanceof LivingEntity) {
             Set<AttributeInstance> set = ((LivingEntity) this.entity).getAttributes().getDirtyAttributes();
-
+            // Plazma start - MultiThreadedTracker: sync
             if (!set.isEmpty()) {
-                // CraftBukkit start - Send scaled max health
-                if (this.entity instanceof ServerPlayer) {
-                    ((ServerPlayer) this.entity).getBukkitEntity().injectScaledMaxHealth(set, false);
-                }
-                // CraftBukkit end
-                this.broadcastAndSend(new ClientboundUpdateAttributesPacket(this.entity.getId(), set));
-            }
+                final var copy = Lists.newArrayList(set);
 
+                ((ServerLevel) this.entity.level).chunkSource.chunkMap.runOnTrackerMainThread(() -> {
+                    if (this.entity instanceof ServerPlayer) ((ServerPlayer) this.entity).getBukkitEntity().injectScaledMaxHealth(copy, false); // CraftBukkit - Send scaled max health
+                    this.broadcastAndSend(new ClientboundUpdateAttributesPacket(this.entity.getId(), copy));
+                });
+            }
+            // Plazma end
             set.clear();
         }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index ad779ded0ead62b456c1b96109eba221f92153b3..245cca97718eaa70988b9e05a8bf9d42feadabfe 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -2501,7 +2501,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public LevelEntityGetter<Entity> getEntities() {
-        org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot // Plazma - MultiThreadedTracker: async
         return this.entityLookup; // Paper - rewrite chunk system
     }
 
diff --git a/src/main/java/org/plazmamc/plazma/configurations/LevelConfigurations.java b/src/main/java/org/plazmamc/plazma/configurations/LevelConfigurations.java
index e6c22ab535ab8fecaadbf06d4982440fd5863f17..973e37ea669be6dccdf2949402a2a0c0e1bd746c 100644
--- a/src/main/java/org/plazmamc/plazma/configurations/LevelConfigurations.java
+++ b/src/main/java/org/plazmamc/plazma/configurations/LevelConfigurations.java
@@ -107,5 +107,12 @@ public class LevelConfigurations extends ConfigurationPart {
 
         }
 
+        public MultiThreadedTracker multiThreadedTracker;
+        public class MultiThreadedTracker extends ConfigurationPart {
+
+            public boolean enabled = DO_OPTIMIZE;
+
+        }
+
     }
 }
diff --git a/src/main/java/org/plazmamc/plazma/tracker/MultithreadedTracker.java b/src/main/java/org/plazmamc/plazma/tracker/MultithreadedTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..8123cbba4630ff23dc80301b9167fb21afca3e0f
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/tracker/MultithreadedTracker.java
@@ -0,0 +1,148 @@
+package org.plazmamc.plazma.tracker;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
+import io.papermc.paper.world.ChunkEntitySlices;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.chunk.LevelChunk;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class MultithreadedTracker {
+    private static final int parallelism = Math.max(4, Runtime.getRuntime().availableProcessors());
+    private static final Executor trackerExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
+            .setNameFormat("plazma-tracker-%d")
+            .setPriority(Thread.NORM_PRIORITY - 2)
+            .build());
+    private final IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks;
+    private final AtomicInteger taskIndex = new AtomicInteger();
+    private final ConcurrentLinkedQueue<Runnable> mainThreadTasks;
+    private final AtomicInteger finishedTasks = new AtomicInteger();
+
+    public MultithreadedTracker(IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks, ConcurrentLinkedQueue<Runnable> mainThreadTasks) {
+        this.entityTickingChunks = entityTickingChunks;
+        this.mainThreadTasks = mainThreadTasks;
+    }
+
+    public void tick() {
+        int iterator = this.entityTickingChunks.createRawIterator();
+
+        if (iterator == -1) {
+            return;
+        }
+
+        // start with updating players
+        try {
+            this.taskIndex.set(iterator);
+            this.finishedTasks.set(0);
+
+            for (int i = 0; i < parallelism; i++) {
+                trackerExecutor.execute(this::runUpdatePlayers);
+            }
+
+            while (this.taskIndex.get() < this.entityTickingChunks.getListSize()) {
+                this.runMainThreadTasks();
+                this.handleChunkUpdates(5); // assist
+            }
+
+            while (this.finishedTasks.get() != parallelism) {
+                this.runMainThreadTasks();
+            }
+
+            this.runMainThreadTasks(); // finish any remaining tasks
+        } finally {
+            this.entityTickingChunks.finishRawIterator();
+        }
+
+        // then send changes
+        iterator = this.entityTickingChunks.createRawIterator();
+
+        if (iterator == -1) {
+            return;
+        }
+
+        try {
+            do {
+                LevelChunk chunk = this.entityTickingChunks.rawGet(iterator);
+
+                if (chunk != null) {
+                    this.updateChunkEntities(chunk, TrackerStage.SEND_CHANGES);
+                }
+            } while (++iterator < this.entityTickingChunks.getListSize());
+        } finally {
+            this.entityTickingChunks.finishRawIterator();
+        }
+    }
+
+    private void runMainThreadTasks() {
+        try {
+            Runnable task;
+            while ((task = this.mainThreadTasks.poll()) != null) {
+                task.run();
+            }
+        } catch (Throwable throwable) {
+            MinecraftServer.LOGGER.warn("Tasks failed while ticking track queue", throwable);
+        }
+    }
+
+    private void runUpdatePlayers() {
+        try {
+            while (handleChunkUpdates(10)) ;
+        } finally {
+            this.finishedTasks.incrementAndGet();
+        }
+    }
+
+    private boolean handleChunkUpdates(int tasks) {
+        int index;
+        while ((index = this.taskIndex.getAndAdd(tasks)) < this.entityTickingChunks.getListSize()) {
+            for (int i = index; i < index + tasks && i < this.entityTickingChunks.getListSize(); i++) {
+                LevelChunk chunk = this.entityTickingChunks.rawGet(i);
+                if (chunk != null) {
+                    try {
+                        this.updateChunkEntities(chunk, TrackerStage.UPDATE_PLAYERS);
+                    } catch (Throwable throwable) {
+                        MinecraftServer.LOGGER.warn("Ticking tracker failed", throwable);
+                    }
+
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private void updateChunkEntities(LevelChunk chunk, TrackerStage trackerStage) {
+        final ChunkEntitySlices entitySlices = chunk.level.getEntityLookup().getChunk(chunk.locX, chunk.locZ);
+        if (entitySlices == null) {
+            return;
+        }
+
+        final ChunkMap chunkMap = chunk.level.chunkSource.chunkMap;
+
+        for (Entity entity : entitySlices.getAllEntities()) {
+            if (entity != null) {
+                ChunkMap.TrackedEntity entityTracker = chunkMap.entityMap.get(entity.getId());
+                if (entityTracker == null) continue;
+                Class<?> superClass = entityTracker.getClass().getSuperclass();
+                if (!superClass.equals(ChunkMap.TrackedEntity.class)) { // check custom tracker
+                    if (trackerStage == TrackerStage.SEND_CHANGES) {
+                        entityTracker.serverEntity.sendChanges();
+                    } else if (trackerStage == TrackerStage.UPDATE_PLAYERS) {
+                        entityTracker.updatePlayers(entityTracker.getEntity().getPlayersInTrackRange());
+                    }
+                }
+            }
+        }
+    }
+
+    private enum TrackerStage {
+        UPDATE_PLAYERS,
+        SEND_CHANGES
+    }
+}
